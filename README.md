# geo-service

<p>
  Проект представляет из себя класическое spring-boot приложение, собираемое через maven.
В соответствии с заданием в корневой директории проекта расположен jar файл приложения. Обратите внимание, что launch_script.sh запускает приложение из папки target.
  </p>

<p>
  
Данные для приложения лежат в src/main/resources. 
Имеется возможность их перегенерировать с помощью main класса ru.kolpakov.test.geoservice.GeoServiceDataGenerator, 
где можно указать выходную директорию, среднюю ошибку измерения дистанции и количество генерируемых пользователей.
Пользователи распределяются по ячейкам случайным образом. В этом репозитории а таблице для пользователей лежит один миллион униказльных записей.
</p>
<br>
<p>
Для запуска приложения исользуется скрипт launch_script.sh в корне проекта. 
С помощью модификации скрипта можно настроить:
<ul>
<li>порт, на котором стартует приложение(--server.port)</li>
<li>расположение входных данных для таблицы с пользователями(--users.table.path)</li>
<li>расположения входных данных для таблицы с ячейками(--geo.cells.table.path)</li>
<li>уровня логгирования классов приложения (--logging.level.ru.kolpakov.test)</li>
</ul>
Файлы входных данных для таблиц должны представлять из себя csv файл с разделителем ";" и без заголовков, и столбцами id, lon, lat для таблицы пользователей, 
и столбцами lon, lat, distanceError для таблицы ячеек.
</p>
<p>
Приложение предоставляет 4 метода в HTTP API:
<ul>
<li>GET /cell_stat?lon=${lon}&lat=${lat} для определения количества узлов в ячейке, амортизированная сложность запроса O(1), в худшем случае O(p), где p - количество потоков одновременно загружающих метку в данныую ячейку</li>
<li>PUT /user_label/${id} -d '{"lon":${lon}, "lat":${lat}}'для добавления и обновления метки пользователя, амортизированная сложность запроса O(1), в худшем случае O(log n * p * log p), где p - количество потоков, одновременно обновляющих или удаляющих метку. log n получаем от скошенного распределения id пользователей, когда в бакете содержащем, метку пользователя, загружается непропорционально много меток, а p * log p  получаем от попыток захвата блокировки умноженного на сложность добавления lock'а в map lock'ов, когда в бакете, содержащем lock для метки, загруженно непропоционально много lock'ов </li>
<li>DELETE /user_label/${id} для удаления метки пользователя, амортизированная сложность запроса O(1), в худшем случае O(log n * p * log p), где p - количество потоко, одновременно обновляющих или удаляющих метку</li>
<li>GET /placement?id=${id}&lon=${lon}&lat=${lat} определение, находится ли пользователь рядом с меткой, амортизированная сложность запроса O(1), в худшем случае O(log n * p * log p), где p - количество потоков, одновременно обновляющих или удаляющих метку</li>
</ul>
<p>
Приложение считывает входные данные для таблиц при запуске. 
</br>
Основной класс приложения(реализация логики хранения): ru.kolpakov.test.geoservice.storage.GeoStorage.
</br>
Поля класса представляют собой индексы по координатам для ячеек и по айди для пользователей. При масштабировании решения, возможно для хранения индексов перестанет хватать памяти и понадобится добавлять какую-либо БД для храненения меток и ячеек.
</br>
Для определения количества узлов в ячейке для каждого узла ведется атомарный счетчик узлов.
Сетка имеет наипростейший вид(ячейки 1 градус по меридиану на 1 градус по параллели), что может быть неадекватно для реальных use-case'ов, когда некоторые ячейки будут незаполнены(Антарктида, океаны), а некоторые(Япония, Москва, Европа) переполнены(будут происходить слишком частые запросы к счетчику пользователей для самых заполненных ячеек, что может стать bottleneck'ом решения). Соответственно одним из шагов развития решения может быть усложнение сетки: например использование Quadtree для уменьшения размера заполненных ячеек. В текущем решении невозможно эффективно реализовать функционал получения пользователей, находящихся в одной из ячеек, поскольку для ячеек ведутся только счетчики.
</br>
Для потокобезопасной работы все операции работы с метками пользователей(обновление, удаление, расчет нахождения рядом с меткой) захватывают блокировку на метку(id записи), при чём для обновления и удаления завхватывается блокирока на запись, а для расчета нахождения с меткой - блокировка на чтение. Если рассматривать вызов метода на изменение пользователя как HTTP запрос, а не запрос к классу GeoStorage, то сейчас некоторые методы могут вернуть результат, который может быть неактуальным на момент создания ответа(например если во время запроса на количество узлов в ячейке в эту ячейку будут добавлены или удалены метки).
</br>
Код содержит unit-тесты для приложения, в идеале стоило бы добавить функциональные тесты(запрос к storage через контроллер, а не напрямую) и больше тестов на потокобезопасность.
</p>
